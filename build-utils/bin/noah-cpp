#!/usr/bin/env node

// Linked by Jytron 5 Linker tool
function OBJ_FILE(){};




OBJ_FILE('/****SRC-OBJECT:"noah-cpp.ls" ****/');

// Generated by LiveScript 1.2.0
/**
* Created:  2014-09-16
* Author:   Oscar Campbell
* Licence:  MIT (Expat) - http://opensource.org/licenses/mit-license.html
**/
var initProf, util, fs, argv, colors, VERSION, DEBUG_COMPILER, IS_DEV, W, now, puts, print, say, _T, _E, _W, _D, _DF, _JF, die, min, max, nop, RE, applyIf, pad, textAddLineNumbers, _SRC, isStr, stacklift, acheInvocation, allowedItTypes, ache, u, REgm, extractHeader, processFile, handleFile, handleStdin, main, slice$ = [].slice;
initProf = +new Date;
util = require('util');
fs = require('fs');
argv = require('optimist').string('o').boolean('fixed-path').argv;
colors = require('colors');
VERSION = '14.11.19';
DEBUG_COMPILER = true;
IS_DEV = false;
W = global;
now = function(){
  return +new Date();
};
puts = function(txt){};
print = function(line){
  process.stdout.write(line);
};
say = _T = _E = _W = _D = _DF = _JF = function(){
  var arg, out, i$, len$, i;
  arg = slice$.call(arguments);
  out = '';
  for (i$ = 0, len$ = arg.length; i$ < len$; ++i$) {
    i = arg[i$];
    if (typeof i === 'object' && i !== null) {
      if (i.message) {
        out += i.message;
      } else {
        out += JSON.stringify(i);
      }
    } else {
      out += i;
    }
    out += ' ';
  }
  puts(out);
};
die = function(code, msg){
  if (typeof code === 'string') {
    msg = code;
    code = 1;
  }
  return process.stdout.on('close', function(){
    say('dies with:', msg || '');
    return process.exit(code);
  });
};
min = Math.min, max = Math.max;
nop = function(){};
RE = function(re, opt){
  opt == null && (opt = 'gm');
  return new RegExp(re, opt);
};
applyIf = function(object, config){
  var property;
  if (object) {
    for (property in config) {
      if (object[property] === undefined) {
        object[property] = config[property];
      }
    }
  }
  return object;
};
String.prototype.indexOfUnescaped = function(str, pos){
  var lookBack, escCount;
  pos || (pos = 0);
  for (;;) {
    pos = this.indexOf(str, pos);
    if (pos <= 0) {
      return pos;
    } else {
      lookBack = 1;
      while (pos - lookBack >= 0 && this.charAt(pos - lookBack) === '\\') {
        lookBack++;
      }
      escCount = lookBack - 1;
      if ((escCount & 1) === 0) {
        return pos;
      } else {
        pos++;
      }
    }
  }
};
pad = function(n, c, char){
  char == null && (char = ' ');
  if ((n = n + "").length < c) {
    return new Array(++c - n.length).join(char) + n;
  } else {
    return n;
  }
};
textAddLineNumbers = function(text, ofs){
  var i$, len$, rowIx, row;
  text = text.split('\n');
  ofs || (ofs = 1);
  for (i$ = 0, len$ = text.length; i$ < len$; ++i$) {
    rowIx = i$;
    row = text[i$];
    text[rowIx] = pad(rowIx + ofs, 5) + ' ' + row;
  }
  text = text.join('\n');
  return text;
};
_SRC = function(){
  var arg, out, i$, len$, i;
  arg = slice$.call(arguments);
  if (arg.length === 1 && typeof arg[0] !== 'string' && arg[0].length) {
    arg = arg[0];
  }
  out = '';
  for (i$ = 0, len$ = arg.length; i$ < len$; ++i$) {
    i = arg[i$];
    if (typeof i === 'object') {
      if (i.message) {
        out += i.message;
      } else {
        out += JSON.stringify(i);
      }
    } else {
      out += i;
    }
    out += ' ';
  }
  out += '\n';
  out = textAddLineNumbers(out.replace(/error/igm, 'E-RRO-R'));
  return puts(out);
};
if (!DEBUG_COMPILER) {
  _T = nop;
}
isStr = function(value){
  return typeof value === 'string';
};
stacklift = function(fn){
  process.nextTick(fn);
};
acheInvocation = 1;
if (IS_DEV) {
  allowedItTypes = {
    own: 1,
    all: 1,
    obj: 1,
    arr: 1,
    keys: 1
  };
}
ache = function(type, list, iterator, afterLoop){
  var keyParam, completed, invocation, listLen, keyList, key, val, iterate, own$ = {}.hasOwnProperty;
  keyParam = false;
  if (isStr(type)) {
    if (type === 'keys') {
      keyParam = true;
      type = null;
    }
  } else {
    afterLoop = iterator;
    iterator = list;
    list = type;
    type = null;
  }
  if (!list) {
    return afterLoop();
  }
  type || (type = list.length != null ? 'arr' : 'own');
  if (IS_DEV) {
    if (!allowedItTypes[type]) {
      die('ache(): Not an allowed iteration-style!', type, 'use', allowedItTypes);
    }
    if (!isFn(afterLoop)) {
      die('ache(): needs an afterLoop-part!');
    }
  }
  completed = 0;
  invocation = acheInvocation++;
  if (type === 'arr') {
    listLen = list.length;
  } else {
    keyList = [];
    for (key in list) if (own$.call(list, key)) {
      val = list[key];
      keyList.push(key);
    }
    listLen = keyList.length;
  }
  if (listLen === 0) {
    return afterLoop();
  }
  iterate = function(){
    var iterateCb, key;
    iterateCb = function(err){
      if (err) {
        if (err === -1) {
          err = null;
        }
        afterLoop(err);
        afterLoop = null;
      } else {
        completed++;
        if (IS_DEV) {
          if (completed > listLen) {
            _E('"completed" is > list-length! callback called twice somewhere!', completed, listLen);
          }
        }
        if (completed === listLen) {
          afterLoop();
        } else {
          iterate();
        }
      }
    };
    if (type === 'arr') {
      key = completed;
    } else {
      key = keyList[completed];
    }
    stacklift(function(){
      if (keyParam) {
        iterator.call(W, list[key], key, iterateCb);
      } else {
        iterator.call(W, list[key], iterateCb);
      }
    });
  };
  iterate();
};
if ((typeof module != 'undefined' && module !== null ? module.exports : void 8) != null) {
  u = module.exports;
} else if ((W != null ? W.utils : void 8) != null) {
  u = W.utils;
} else if (typeof global != 'undefined' && global !== null) {
  u = global;
} else {
  u = window;
}
_D('initProf took', now() - initProf + 'ms');
RE = function(str, opts){
  var re;
  re = new RegExp(str, opts);
  _T('Constructed new RegExp: ', re.toString());
  return re;
};
REgm = function(str){
  return RE(str, 'gm');
};
extractHeader = function(src){
  var rows, header, compensate_rows, state, ifdefsInInterface, i$, len$, row;
  rows = src.split(/\n/);
  header = '';
  compensate_rows = 3;
  state = 0;
  ifdefsInInterface = 0;
  for (i$ = 0, len$ = rows.length; i$ < len$; ++i$) {
    row = rows[i$];
    if (state === 1) {
      if (row.match(/^\s*#if/)) {
        ifdefsInInterface++;
      }
      if (row.match(/^\s*#endif/)) {
        ifdefsInInterface--;
        if (ifdefsInInterface === -1) {
          ifdefsInInterface = 0;
          state = 0;
          header += '\n';
          continue;
        }
      }
      header += row + '\n';
    } else {
      if (row.match(/^\s*#ifdef INTERFACE/)) {
        state = 1;
      }
      if (compensate_rows === 0) {
        header += '\n';
      } else {
        compensate_rows--;
      }
    }
  }
  if (header) {
    header += '\n\n#undef INTERFACE\n#endif\n';
  }
  return header;
};
processFile = function(filepath, opts){
  var headerPath, defString, src, e, prevHeader, header, headerBody, exec;
  headerPath = filepath.replace(/\.([Cc]*)([a-zA-Z0-9]{0,5})$/, function(fm, g1, g2){
    var out;
    out = '.';
    out += (function(){
      switch (g1) {
      case 'C':
        return 'H';
      case 'CC':
        return 'HH';
      case 'CPP':
        return 'HPP';
      case 'c':
        return 'h';
      case 'cc':
        return 'hh';
      case 'cpp':
        return 'hpp';
      }
    }());
    out += g2;
    return out;
  });
  if (opts.outDir) {
    if (opts.fixedPath) {
      headerPath = headerPath.replace(/^.*?([^/]+)$/, opts.outDir + '$1');
    } else {
      headerPath = headerPath.replace(/([^/]+)$/, opts.outDir + '$1');
    }
  }
  defString = headerPath.replace(/.*?([^/]+)$/, "_$1_").replace(/[^a-zA-Z0-9_]/g, '_').toUpperCase();
  try {
    src = fs.readFileSync(filepath, 'utf8');
  } catch (e$) {
    e = e$;
    _D('ERROR when reading file ', filepath, e.message);
    return;
  }
  try {
    prevHeader = fs.readFileSync(headerPath, 'utf8');
  } catch (e$) {
    e = e$;
    prevHeader = '';
  }
  header = "";
  header += '#pragma once' + "\n";
  header += '#ifndef ' + defString + "\n";
  header += '#define ' + defString + "\n";
  header += "/* THIS HEADER FILE IS AUTO GENERATED FROM \"" + filepath + "\" WITH \"noah-cpp\" - DO NOT EDIT! ALERT!! */";
  headerBody = extractHeader(src);
  if (headerBody === "") {
    say("No header contents to generate");
    exec("rm -rf " + headerPath, function(c, o, e){
      _D('(Tried) deleting empty header file - if it existed... ' + headerPath);
    });
    return;
  }
  header += headerBody;
  try {
    fs.writeFileSync(headerPath, header);
    exec = require('child_process').exec;
    exec("chmod 444 " + headerPath, function(c, o, e){
      return;
    });
  } catch (e$) {
    e = e$;
    _D('ERROR when writing file ', headerPath, e.message);
    return;
  }
};
handleFile = function(){
  var files, opts, i$, len$, filepath;
  files = argv._;
  opts = {
    outDir: argv.o || './',
    fixedPath: argv["fixed-path"] || false
  };
  for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
    filepath = files[i$];
    processFile(filepath, opts);
  }
};
handleStdin = function(){
  var code, stdin;
  code = '';
  stdin = process.openStdin();
  stdin.setEncoding('utf8');
  stdin.on('data', function(buffer){
    if (buffer) {
      code += buffer.toString();
    }
  });
  stdin.on('end', function(){
    var ref$, implementation, header;
    ref$ = transpileSource(code, 'cu++'), implementation = ref$[0], header = ref$[1];
    _D('implementation is', implementation);
    print(implementation);
  });
};
main = function(){
  if (argv.i) {
    _D('does stdin');
    return handleStdin();
  } else {
    puts = function(txt){
      console.error(txt);
    };
    return handleFile();
  }
};
main();
