
//-- rules:
//--
//-- Foundational parser view of transpiled code:
//--  - States are: expressionish, stringish, comment
//--  - and perhaps: class, switch, constructor (for init list)
//--  - In expressionish state, parens of all types are balance counted
//--  - at indent-fallback, we keep open if:
//--    - parens are unbalanced
//--    - next token is {, <<, >>
//--
//-- /(^|\s\s)--\s+/    - is one-line-comment
//-- /((\w+-)+\w+)/     -> \w_\w...
//-- /(if|for|switch|while|else if|elif|else)/ .. last line before closing indent to ind+1 `$1 ($2) {`
//-- dedent when depth > 0 `}`
//-- any row not 'block-staring-op' is finalized with `;` WHEN it dedents to it's opening indent AND next char != /[{,:]/
//-- functions are: /{{IDENT}}\s*\(.*\)\s*->\s*

    /*
    PARSING:

    1. keywords - since they're specific and fast to match
    2. Operators, precedence-parens, etc. fundamentals
    2. function call
    3. function-def


    identifer:              [a-zA-Z_-][a-zA-Z0-9_-]*
    data-type:              [a-zA-Z_-][a-zA-Z0-9_-]* (template-parameters?)
    template-parameters:    `<` (list: (data-type | literal), separator: /,\n|\n/) `>`
    function-header:        identifier `(` parameter-list `)` \s* `->` \s* data-type  , fast-match: /[a-zA-Z_-][a-zA-Z0-9_-]*\(.*\)\s*->\s(\n|\{|=>}/ on all lines from current til dedent (in case of "expression/statement over several lines")
    function-decl:          function-header eof-expression
    function-def:           function-header some-block
    some-block:             !STORE-indent! (brace-block | arrow-block | implicit-block)
    brace-block:            ( (`{`) | (`\n` stashed-indent `{`) ) block-body ( stashed-indent `}` )
    block-body:             !stashed-indent++!:   ( `\n` stashed-indent expression ) | expression

    */





/**
* Created:  2014-11-12
* Author:   Oscar Campbell
* Licence:  MIT (Expat) - http://opensource.org/licenses/mit-license.html
* Code Cls: Blackbox Some Metal
**/

#include <cerrno>
#include <cstring>
#include <vector>
#include <algorithm>
#include <fstream>
#include <cmath>
#include <boost/format.hpp>

#include "QuantBase.hh"
#include "QuantTime.hh"
#include "MutatingString.hh"
#include "MutatingBuffer.hh"

require SQDI-Ticks-Abstract
require SQDI-Sys-T23M-Abstract


//-- #define MONTHLY

/*
                        #### ##    ## #### ########
                         ##  ###   ##  ##     ##
                         ##  ####  ##  ##     ##
                         ##  ## ## ##  ##     ##
                         ##  ##  ####  ##     ##
                         ##  ##   ###  ##     ##
                        #### ##    ## ####    ##
*/


SESSION-BREAK-PAGE-COUNT ¤int = 2
// typedef SQDI-Sys-T23M-Abstract<QuantTick, QuantProfileEnum::LOADING-FILES-T23M>
//SQDI-T23M-Quant-Abstract

typedef SQDI-T23M-Quant-Abstract = SQDI-Sys-T23M-Abstract<QuantTick, QuantProfileEnum::LOADING-FILES-T23M>


class SQDI-Ticks-T23M
    extends
        public SQDI-T23M-Quant-Abstract,
        public SQDI-Ticks-Abstract
{
    friend class SQDI-Sys-T23M-Abstract

  public:
    constructor(write-mode bool = false) -> {
            :> SQDI-T23M-Quant-Abstract(write-mode, SESSION-BREAK-PAGE-COUNT)
            :> SQDI-Ticks-Abstract(), :> write-mode_ { write-mode }
            // No constructor code - it's all done in the init-list part above..
    }

    destructor() -> {}

    init(p-broker-id string, p-symbol string) -> bool  [final]
    read-tick!(tick QuantTick&) -> bool  [final]
    write-tick!(tick ¤QuantTick&) -> bool

  protected:
    //-- generate-locator-path ~ (time-pos ~ pxt::ptime) -> const char*
    //--  *TODO*
    //-- advance-page ~ () -> void

    generate-locator-path() -> string
    read-page-header(byte*) -> byte*
    write-page-header(byte*) -> byte*

  private:
    calculate-point-factors() -> void
    make-case-for-getting-more-data() -> bool
    make-case-for-new-page() -> void

    write-mode_           bool = false
    broker-id             string
    symbol                string
    filename-formatter_   boost::format
    chunk-time-pos        pxt::ptime
    next-chunk-time-pos   pxt::ptime

    //-- #ifdef MONTHLY
    //-- ¤int session-break-duration-in-chunk-units = 0
    //-- boost::gregorian::months chunk-unit-duration  //-- pxt::hours(7*24)
    //-- #else

    session-break-duration-in-chunk-units ~ ¤int = SESSION-BREAK-PAGE-COUNT
    chunk-unit-duration ~ pxt::time-duration

    //-- #endif

    price-point-factor        real
    volume-point-factor       real
    price-point-div-factor    real
    volume-point-div-factor   real

    prev-raw-tick  QuantTickFixed

    //-- qts::enum-resolution::MILLIS
    current-time-resolution  qts::enum-resolution = qts::MILLIS
    current-time-uncertainty  int
    current-price-decimal-count  int
    current-volume-decimal-count  int
}


/*
                                     #######
         #####  ######   ##   #####     #    #  ####  #    #
         #    # #       #  #  #    #    #    # #    # #   #
         #    # #####  #    # #    #    #    # #      ####
         #####  #      ###### #    #    #    # #      #  #
         #   #  #      #    # #    #    #    # #    # #   #
         #    # ###### #    # #####     #    #  ####  #    #
*/

SQDI-Ticks-T23M::read-tick!(tick QuantTick&) -> bool {
        /*
        //-- _DPn("readTick()")
        */
        //-- #ifdef IS-DEBUG
        profiler.start(DECODING-FILES-T23M)
        //-- #endif
        /*
            //-- _DPn(1)
        */
        //-- u8* rdptr = raw-buffer.on-free-leash-for(100)
        //-- if rdptr == raw-buffer.end()
        if raw-buffer.is-at-end()
            if false == make-case-for-getting-more-data()
                tick.time =< pxt::max-date-time
                return false

        rdptr ~ byte* = raw-buffer.on-free-leash-for(100)

        // defines rdptr ~ auto with result of ...
        rdptr2 ~= raw-buffer.on-free-leash-for(100)


        /*
            //-- _DPn(2)

            _DP("raw-buffer is\n"
                << " size: " << raw-buffer.size() << "\n"
                << " capacity: " << raw-buffer.capacity() << "\n"
                << " start: " << (V*)raw-buffer.front() << "\n"
                << " end: " << (V*)raw-buffer.end() << "\n"
                << " limit: " << (V*)raw-buffer.limit() << "\n")
        */
        //-- raw-buffer.verify-pointer(rdptr)
        //-- Time moves forward only - hence natural (unsigned) varint
        prev-raw-tick.time += read-varilen-natural<uint64-t>(rdptr)
        prev-raw-tick.ask += read-varilen-integer<int>(rdptr)
        prev-raw-tick.bid += read-varilen-integer<int>(rdptr)
        prev-raw-tick.ask-volume += read-varilen-integer<int>(rdptr)
        prev-raw-tick.bid-volume += read-varilen-integer<int>(rdptr)
        raw-buffer.catch-up-reads(rdptr)
        tick.time =
            qts::ptime-from-ms(prev-raw-tick.time * current-time-uncertainty)
        tick.last-price = tick.ask = prev-raw-tick.ask * price-point-div-factor
        tick.bid = prev-raw-tick.bid * price-point-div-factor
        tick.ask-volume = prev-raw-tick.ask-volume * volume-point-div-factor
        tick.bid-volume = prev-raw-tick.bid-volume * volume-point-div-factor
        //--      cerr << "Specific decode Tick is: " << tick.ask << ", " << tick.bid
        //-- <<
        //-- ", " << tick.ask-volume << " at " << 47 << "/" << byte-buffer-size <<
        //-- "\n"
        //-- cerr << "SQDI-Ticks-T23M::readTick: " << tick.time
        //--     << " ~k:" << tick.ask << " bid: " << tick.bid << "\n"
        //-- #ifdef IS-DEEPBUG
        //-- cerr << symbol << "::readTick(): " << tick.to-str() << " (end - ptr) = "
        //-- <<
        //-- (byte-buffer-end - rdptr) << "\n"
        //-- #endif
        //-- #ifdef IS-DEBUG
        profiler.end(DECODING-FILES-T23M)
        //-- #endif
        return true
}
/*
                                      #######
         #    # #####  # ##### ######    #    #  ####  #    #
         #    # #    # #   #   #         #    # #    # #   #
         #    # #    # #   #   #####     #    # #      ####
         # ## # #####  #   #   #         #    # #      #  #
         ##  ## #   #  #   #   #         #    # #    # #   #
         #    # #    # #   #   ######    #    #  ####  #    #

*/
SQDI-Ticks-T23M::write-tick! ~ (tick ~ ¤QuantTick&) -> bool = {
        _D("writeTick()"
           << "\n")
        //-- #ifdef IS-DEBUG
        start(profiling, ENCODING-DATA)
        //-- profiler.start( ENCODING-DATA )
        //-- #endif
        _DP(" 1 ")
        if tick.time >= next-chunk-time-pos
            _DPn("\n\nPassed chunk time break - init a new chunk aight!\n\n")
            make-case-for-new-page()

        _DP(" 2 ")
        //-- *TODO* hardcoded for millis.. - 2014-11-10/Oscar Campbell
        raw-tick ~ QuantTickFixed(
            qts::millis(tick.time) / current-time-uncertainty,
            tick.ask * price-point-factor, tick.bid * price-point-factor,
            tick.ask * price-point-factor, tick.ask-volume * volume-point-factor,
            tick.bid-volume * volume-point-factor
        )
        _DP(" 3 ")
        //-- cerr << "Plain-tick: " << tick.to-str() << "\n"
        //-- cerr << "The muddafuckin raw-tick = " << raw-tick.to-str() << "\n"
        /*
        cerr << "The muddafuckin deltas: "
            << raw-tick.time - prev-raw-tick.time << ", "
            << raw-tick.ask - prev-raw-tick.ask << ", "
            << raw-tick.bid - prev-raw-tick.bid << ", "
            << raw-tick.ask-volume - prev-raw-tick.ask-volume << ", "
            << raw-tick.bid-volume - prev-raw-tick.bid-volume
            << "\n"
        */
        wrpos ~ ^byte = raw-buffer.on-free-leash-for(100)
        raw-buffer.verify-pointer(wrpos)
        _DP(" 4.1 ")
        //-- Time moves forward only - hence natural number, unsigned,_varint
        write-varilen-natural<uint64-t>(wrpos, raw-tick.time - prev-raw-tick.time)
        //-- _DP(" 4.2 ")
        //-- raw-buffer.verify-pointer(wrpos)
        write-varilen-integer(wrpos, raw-tick.ask - prev-raw-tick.ask)
        //-- _DP(" 4.3")
        //-- raw-buffer.verify-pointer(wrpos)
        write-varilen-integer(wrpos, raw-tick.bid - prev-raw-tick.bid)
        //-- _DP(" 4.4 ")
        //-- raw-buffer.verify-pointer(wrpos)
        write-varilen-integer(wrpos,
                              raw-tick.ask-volume - prev-raw-tick.ask-volume)
        //-- _DP(" 4.5 ")
        //-- raw-buffer.verify-pointer(wrpos)
        write-varilen-integer(wrpos,
                              raw-tick.bid-volume - prev-raw-tick.bid-volume)
        //-- _DP(" 4.6 ")
        _DP(" 5 ")
        raw-buffer.verify-pointer(wrpos)
        raw-buffer.catch-up-writes(wrpos)
        _DP(" 6 ")
        raw-buffer.verify-pointer(wrpos)
        //-- By using pointers we could simply swap the pointers in the vars here for
        //-- further efficiancy...
        prev-raw-tick = raw-tick
        _DP(" 7 ")
        persist-maybe()
        _DP(" 8 ")
        raw-buffer.verify-pointer(wrpos)
        //--      cerr << "Specific decode Tick is: " << tick.ask << ", " << tick.bid
        //-- << ", " << tick.ask-volume << " at " << 47 << "/" << byte-buffer-size <<
        //-- "\n"
        //-- cerr << "SQDI-Ticks-T23M::readTick: " << tick.time << "
        //-- ~k: " << tick.ask << " bid: " << tick.bid << "\n"
        //-- #ifdef IS-DEEPBUG
        //-- cerr << symbol << "::readTick(): " << tick.to-str() << " (end - ptr) = "
        //-- << (byte-buffer-end - rdptr) << "\n"
        //-- #endif
        //-- #ifdef IS-DEBUG
        stop(profiling, ENCODING-DATA)
        //-- #endif
        //-- _DPn("writeTick() DONE")
        return true
}

#endif

#include "QuantProfiling.hh"

clear ~ (tick ~ QuantTickFixed& ) -> void = {
        with tick
        .time = .ask = .bid = .ask-volume = .bid-volume = .last-price = 0
        without tick
}

/*
  #####  #          #     #####   #####     ### #     # ### #######
 #     # #         # #   #     # #     #     #  ##    #  #     #
 #       #        #   #  #       #           #  # #   #  #     #
 #       #       #     #  #####   #####      #  #  #  #  #     #
 #       #       #######       #       #     #  #   # #  #     #
 #     # #       #     # #     # #     #     #  #    ##  #     #
  #####  ####### #     #  #####   #####     ### #     # ###    #

*/

SQDI-Ticks-T23M::
init ~ (p-broker-id ~ string, p-symbol ~ string) -> bool = {
        broker-id = p-broker-id
        symbol = p-symbol
        //-- *TODO* day iterator
        chunk-unit-duration = pxt::hours(24)
        chunk-time-pos =
            qts::get-prior-aligned-ts(start-date_, chunk-unit-duration) -
            chunk-unit-duration  //-- makeTime( "2014-01-07 00:00:00.000" )
        next-chunk-time-pos = chunk-time-pos + chunk-unit-duration
        _DPn("SQDI-Ticks-T23M::init():"
             << "\n"
             << "start-date: " << start-date_ << "\n"
             << "chunk-time-pos: " << chunk-time-pos << "\n")
        base-format ~ const string =
            (boost::format("/usr/local/lib/T23MFW/tickdata/%s/%s/%%04d/%%02d/"
                           "%%02d-ticks.t23mtf") %
             broker-id % symbol).str()
        _DPn("string base-format = boost::format = " << base-format << "\n")
        filename-formatter_ = boost::format(base-format)

        //-- *TODO* *IMPL* spola fram till första tillgängliga fil
        //-- ASSUMED for now!!!

        return true  //-- error *TODO* *IMPL*
}

SQDI-Ticks-T23M::
generate-locator-path ~ () -> string  /i/ {  //-- ¤char * = {
    ymd ~ ? = dt::date(chunk-time-pos.date()).year-month-day()
    return (filename-formatter_ % ymd.year % (int)ymd.month % ymd.day).str()
}

//-- #endif

/*
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ######## ##     ## ########    ######## ########  ######
           ##    ##     ## ##          ##          ##    ##    ##
           ##    ##     ## ##          ##          ##    ##
           ##    ######### ######      ######      ##    ##
           ##    ##     ## ##          ##          ##    ##
           ##    ##     ## ##          ##          ##    ##    ##
           ##    ##     ## ########    ########    ##     ######
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/
SQDI-Ticks-T23M::
calculate-point-factors ~ () -> void  [*inline*] = {
    price-point-factor = pow(10, current-price-decimal-count)
    price-point-div-factor = 1.0 / price-point-factor
    volume-point-factor = pow(10, current-volume-decimal-count)
    volume-point-div-factor = 1.0 / volume-point-factor
}

SQDI-Ticks-T23M::make-case-for-getting-more-data ~ () -> bool = {
    chunk-time-pos += chunk-unit-duration
    next-chunk-time-pos = chunk-time-pos + chunk-unit-duration
    if get-more-data()
        clear(prev-raw-tick)
        return true
    else
        return false
}

SQDI-Ticks-T23M::make-case-for-new-page ~ () -> void = {
    chunk-time-pos = next-chunk-time-pos
    next-chunk-time-pos += chunk-unit-duration

    _DPn("in INIT chunk: chunk-time-pos = " << to-iso-string(chunk-time-pos))
    //-- ↓ *TODO*(2014-11-23/Oscar Campbell) - should be configurable
    //-- ↓ should only have to be done at class configure / construction time - it
    //-- won't change.

    current-time-resolution = qts::enum-resolution::MILLIS
    current-time-uncertainty = 1
    current-price-decimal-count = 5
    current-volume-decimal-count = 2

    calculate-point-factors()
    clear(prev-raw-tick)
    setup-new-output-page()
}

SQDI-Ticks-T23M::read-page-header! ~ (rdptr ~ byte*) -> byte* = {
    _DPn("T23MFWTicks::read-page-header()")

    foo ~ ¤char* = nullptr

    foo = read-string(rdptr)
    if strcmp(foo, broker-id.c-str()) != 0
        cerr << "The file is not formatted correctly. Broker-id didn't match: '"
             << broker-id << "' vs '" << foo << "'\n"
        throw 99

    foo = read-string(rdptr)
    if strcmp(foo, symbol.c-str()) != 0
        cerr << "The file is not formatted correctly. Broker-id didn't match: '"
             << symbol << "' vs '" << foo << "'\n"
        throw 98

    |/ strcmp(foo, symbol.c-str()) != 0
        do-shit()
    |  strcmp(foo, other-symbol.c-str()) != 0
        do-other-shit()
    |_
        do-default-shit()

    |/ strcmp(foo, symbol.c-str()) != 0         =>  do-shit()
    |  strcmp(foo, other-symbol.c-str()) != 0   =>  do-other-shit()
    |_                                          =>  do-default-shit()

    |/ /(strcmp(foo, {{1}}.c-str()) != 0)/    //-- a pattern is added, which is expanded below, with params inserted at {{n}}
    | symbol       =>  do-shit()
    | other-symbol =>  do-other-shit()
    |_             =>  do-default-shit()

    //-- "double pattern"
    |/ /(strcmp(foo, {{1}}.c-str()) != 0)/  =>  /foo = {{1}}/
    | symbol       =>  do-shit()
    | other-symbol =>  do-other-shit()
    |_             =>  do-default-shit()

    //-- A switch is generated when : is after the 'begin branches'-op
    |/: an-expression
    | 47            =>  do-shit()
    | OTHER-CONST   =>  do-other-shit()
    | CONST-VAL     =>  do-more-shit()
    |_              =>  do-default-shit()

    current-time-resolution =
        (qts::enum-resolution)read-varilen-natural<int>(rdptr)
    current-time-uncertainty = read-varilen-natural<int>(rdptr)
    current-price-decimal-count = read-varilen-natural<int>(rdptr)
    current-volume-decimal-count = read-varilen-natural<int>(rdptr)
    calculate-point-factors()
    _DPn("T23MFWTicks::read-page-header() DONE")
    return rdptr
}

SQDI-Ticks-T23M::write-page-header! ~ (wrpos ~ ^byte) -> ^byte = {
    _DP("T23MFWTicks::write-page-header()\n")
    current-time-resolution = qts::enum-resolution::MILLIS
    current-time-uncertainty = 100  //-- 50
    current-price-decimal-count = 5
    current-volume-decimal-count = 2

    write-string(wrpos, broker-id.c-str())
    write-string(wrpos, symbol.c-str())
    write-varilen-natural<int>(wrpos, (int)current-time-resolution)
    write-varilen-natural(wrpos, current-time-uncertainty)
    write-varilen-natural(wrpos, current-price-decimal-count)
    write-varilen-natural(wrpos, current-volume-decimal-count)
    _DPn("T23MFWTicks::write-page-header() DONE")
    return wrpos
}






//#include "MutatingBuffer.hh"
#ifdef INTERFACE
/**
* Created:  2014-11-07
* Author:   Oscar Campbell
* Licence:  MIT (Expat) - http://opensource.org/licenses/mit-license.html
**/

/*
 * * Resources * *
 *
 * http://nadeausoftware.com/articles/2012/05/c-c-tip-how-copy-memory-quickly
 *
 */

#include "rfx11-lib-debug.hh"
#include "rfx11-types.hh"

#include <cstring> // std::memcpy
#include <iostream>

class MutatingBuffer<T> {   // identifier ONLY in template conf is implicit `typedef` (class)
   public:
    MutatingBuffer(minimum-size ~ size-t = 0, fixed-margin ~ size-t = 0) -> {
        :> fixed-margin_{ fixed-margin }
        :> minimum-size_{ minimum-size }

        _Dn( "MutatingBuffer::constructor - A BONA FIDE CONSTRUCTION\n")

        |/ minimum-size
            reserve(minimum-size, false)
        |_
            _Dn("The default fall out")
    }

    MutatingBuffer(is-just-a-reference ~ bool) -> self {
        :> is-just-a-reference_{ is-just-a-reference }
        _Dn( "MutatingBuffer::constructor - JUST AN EMPTY REFERENCE\n")
    }

    MutatingBuffer(MutatingBuffer<T>& other) -> {
        :> buffer-front_{ other._buffer-front_ }
        :> capacity_{ other.size_ }
        :> size_{ other.size_ }
        :> fixed-margin_{ 0 }
        :> minimum-size_{ 0 }
        :> is-just-a-reference_{ true }

        _Dn( "MutatingBuffer::COPY constructor - A CLONED REFERENCE\n")
        _Dn( "buffer_ = " << (void*)buffer-front_ << "\n"
             << "capacity_ = " << capacity_ << "\n"
             << "size_ = " << size_ << "\n"
             << "is-just-a-reference_ = " << is-just-a-reference_ << "\n"
             << "\n")
    }

    MutatingBuffer ~ (other ~ MutatingBuffer<T>&&) -> self = {
        :> buffer-front_{ other.buffer-front_ }
        :> capacity_{ other.size_ }
        :> size_{ other.size_ }, := fixed-margin_{ 0 }
        :> is-just-a-reference_{ true }

        _Dn( "MutatingBuffer::MOVE constructor - A CLONED REFERENCE\n")
        _Dn( "buffer_ = " << (void*)buffer-front_ << "\n"
             << "capacity_ = " << capacity_ << "\n"
             << "size_ = " << size_ << "\n"
             << "is-just-a-reference_ = " << is-just-a-reference_ << "\n"
             << "\n")
    }

    destructor() -> {
        _Dn( "\n\nMutatingBuffer::DESTRUCTOR: clean-uses = " << clean-uses_
             << " mutations = " << mutations_ << "\n")

        |/ is-just-a-reference_ == false {
            _Dn( "Is not a reference only, we delete "
                 << (void*)buffer-front_)
            //delete[] buffer-front_
            free(buffer-front_)
        }
    }

    resize ~(size ~int, maintain-current-data ~bool = true) -> T* = {
        reserve(size, maintain-current-data)
        size_ = size
        buffer-end_ = buffer-front_ + size_
        buffer-cursor_ = buffer-front_
        return buffer-front_
    }

    reserve ~(size ~int, maintain-current-data ~bool = true) -> T* = {
        // *TODO* ~ of 2014-12-29  it always maintains (changed from new/delete to realloc..)
        _Dn( "MutatingBuffer::reserve" << size << "\n")
        assert(is-just-a-reference_ == false)

        if size <= capacity_
            ++clean-uses_
            buffer-end_ = buffer-front_ + size_
            buffer-cursor_ = buffer-front_ // *TODO* - right?
            return buffer-front_

        else {
            ++mutations_
            capacity_ =
                std::max(minimum-size_,
                    int(size + (size / 4) + fixed-margin_)) // the ( size / 4 ) will
            // likely be optimized by
            // gcc et all to ( size >> 2
            // ) while still being clear
            // in code.. - 2014-11-07 /
            // Oscar Campbell
            _Dn( "mutation(): new size is " << size << " new capacity is "
                 << capacity_ << "\n")

            buffer-front_ = (T*) realloc(buffer-front_, capacity_ * sizeof(T)) // nullptr safe

            /*

            T* curr-buf = buffer-front_
            buffer-front_ = new T[capacity_] // Allocate with 25% margin and
                                              // possible fixed margin on top,
                                              // or at least the minimum size.

            if maintain-current-data && curr-buf != nullptr
                std::memcpy((void*)buffer-front_, (void*)curr-buf, size_)
            }

            delete[] curr-buf
            */

            buffer-end_ = buffer-front_ + size_
            buffer-cursor_ = buffer-front_ // *TODO* - right?
            buffer-capacity-end_ = buffer-front_ + capacity_

            return buffer-front_
        }
    }



    /*
        - - - - SYNTAX VARIATIONS BEGINS - - - -
    */

    /*
        - - - - SYNTAX VARIATIONS - - - -  B
    */
    set-specified-buffer-size ~ (size ~ size-t, foo ~ Baloo) void ->  specified-buffer-limit_ = size

    is-at-end! ~ () bool ->
        return (buffer-cursor_ >= buffer-end_)

    is-specification-filled ~ () bool -> {
        _DP("is-specification-filled() -  size = "
            << size_ << " limit = " << specified-buffer-limit_ << "\n")
        return (size_ >= specified-buffer-limit_)
    }

    buffered-count ~ () size-t -> return (std::min(size_, specified-buffer-limit_))

    consume-specified-buffer ~ () T* ->
        local-fn-1 ~ (count ~ int) void -> rewind-shuffle(count)
        local-fn-2 ~ (count ~ int) void -> { rewind-shuffle(count) }
        a-lambda ~= [&](foo ~int) void -> rewind-shuffle(buffered-count())

        if true == false
            rewind-shuffle(buffered-count())
        else
            local-fn1(buffered-count())

        return buffer-front_

    shrink-to-fit! ~ (force ~bool = false, other-thing ~int = 1) void ->
        // We simply ignore this and keep the currently allocated amounts..
        return

    wipe! ~ () void -> { // deliberate free / delete
        ++mutations_
        //delete[] buffer-front_
        free(buffer-front_)
        buffer-cursor_ = buffer-front_ = buffer-end_ = buffer-capacity-end_ =
            nullptr
        capacity_ = size_ = 0
        _Dn( "MutatingBuffer::wipe(): deliberately!\n")
    }

    clear! ~ () void -> { size_ = 0 }


    /*
        - - - - SYNTAX VARIATIONS - - - -  C
    */
    set-specified-buffer-size ~ (size ~ size-t, foo ~ Baloo) -> void =  specified-buffer-limit_ = size

    is-at-end! ~ () -> bool =
        return (buffer-cursor_ >= buffer-end_)

    is-specification-filled ~ () -> bool = {
        _DP("is-specification-filled() -  size = "
            << size_ << " limit = " << specified-buffer-limit_ << "\n")
        return (size_ >= specified-buffer-limit_)
    }

    buffered-count ~ () -> size-t = return (std::min(size_, specified-buffer-limit_))

    consume-specified-buffer ~ () -> T* =
        local-fn-1 ~ (count ~ int) -> void = rewind-shuffle(count)
        local-fn-2 ~ (count ~ int) -> void = { rewind-shuffle(count) }
        a-lambda ~= [&](foo ~int) -> void = rewind-shuffle(buffered-count())

        if true == false
            rewind-shuffle(buffered-count())
        else
            local-fn1(buffered-count())

        return buffer-front_

    shrink-to-fit! ~ (force ~bool = false, other-thing ~int = 1) -> void  =
        // We simply ignore this and keep the currently allocated amounts..
        return

    wipe! ~ () -> void  = { // deliberate free / delete
        ++mutations_
        //delete[] buffer-front_
        free(buffer-front_)
        buffer-cursor_ = buffer-front_ = buffer-end_ = buffer-capacity-end_ =
            nullptr
        capacity_ = size_ = 0
        _Dn( "MutatingBuffer::wipe(): deliberately!\n")
    }

    clear! ~ () -> void = { size_ = 0; }


    /*
        - - - - SYNTAX VARIATIONS - - - -  A
    */
    set-specified-buffer-size (size ~size-t, foo ~Baloo) -> void { specified-buffer-limit_ = size }

    is-at-end!() -> bool
        return (buffer-cursor_ >= buffer-end_)

    is-specification-filled() -> bool {
        _DP("is-specification-filled() -  size = "
            << size_ << " limit = " << specified-buffer-limit_ << "\n")
        return (size_ >= specified-buffer-limit_)
    }

    buffered-count() -> size-t => return (std::min(size_, specified-buffer-limit_))

    consume-specified-buffer() -> T*
        local-fn-1(count ~int) -> void => rewind-shuffle(count)
        local-fn-2(count ~int) -> void { rewind-shuffle(count) }
        a-lambda ~= [&](foo ~int) -> void => rewind-shuffle(buffered-count())

        if true == false
            rewind-shuffle(buffered-count())
        else
            local-fn1(buffered-count())

        return buffer-front_

    shrink-to-fit! (force ~bool = false, other-thing ~int = 1) -> void
        // We simply ignore this and keep the currently allocated amounts..
        return

    wipe!() -> void {    // deliberate free / delete
        ++mutations_
        //delete[] buffer-front_
        free(buffer-front_)
        buffer-cursor_ = buffer-front_ = buffer-end_ = buffer-capacity-end_ =
            nullptr
        capacity_ = size_ = 0
        _Dn( "MutatingBuffer::wipe(): deliberately!\n")
    }

    clear!() -> void    =>      size_ = 0


    /*
        - - - - SYNTAX VARIATIONS - - - -  A-2
    */
    set-specified-buffer-size (size ~size-t, foo ~Baloo) ~void { specified-buffer-limit_ = size }

    is-at-end!() ~bool
        return (buffer-cursor_ >= buffer-end_)

    is-specification-filled() ~bool {
        _DP("is-specification-filled() -  size = "
            << size_ << " limit = " << specified-buffer-limit_ << "\n")
        return (size_ >= specified-buffer-limit_)
    }

    buffered-count() ~size-t => return (std::min(size_, specified-buffer-limit_))

    consume-specified-buffer () ~T*
        local-fn-1(count ~int) ~void => rewind-shuffle(count)
        local-fn-2(count ~int) ~void { rewind-shuffle(count) }
        a-lambda ~= [&](foo ~int) ~void => rewind-shuffle(buffered-count())

        if true == false
            rewind-shuffle(buffered-count())
        else
            local-fn1(buffered-count())

        return buffer-front_

    shrink-to-fit! (force ~bool = false, other-thing ~int = 1) ~void
        // We simply ignore this and keep the currently allocated amounts..
        return

    wipe!() ~void {    // deliberate free / delete
        ++mutations_
        //delete[] buffer-front_
        free(buffer-front_)
        buffer-cursor_ = buffer-front_ = buffer-end_ = buffer-capacity-end_ =
            nullptr
        capacity_ = size_ = 0
        _Dn( "MutatingBuffer::wipe(): deliberately!\n")
    }

    clear!() ~void  =>  size_ = 0


    /*
        - - - - SYNTAX VARIATIONS - - - -  A-3
    */
    set-specified-buffer-size(size size-t, foo Baloo) -> void { specified-buffer-limit_ = size }

    is-at-end!() -> bool
        return (buffer-cursor_ >= buffer-end_)

    is-specification-filled() -> bool {
        _DP("is-specification-filled() -  size = "
            << size_ << " limit = " << specified-buffer-limit_ << "\n")
        return (size_ >= specified-buffer-limit_)
    }

    buffered-count() -> size-t => return (std::min(size_, specified-buffer-limit_))

    consume-specified-buffer() -> T*
        local-fn-1(count int) -> void => rewind-shuffle(count)
        local-fn-2(count int) -> void { rewind-shuffle(count) }
        a-lambda auto = [&](foo int) -> void => rewind-shuffle(buffered-count())

        if true == false
            rewind-shuffle(buffered-count())
        else
            local-fn1(buffered-count())

        return buffer-front_

    shrink-to-fit!(force bool = false, other-thing int = 1) -> void
        // We simply ignore this and keep the currently allocated amounts..
        return

    wipe!() -> void {    // deliberate free / delete
        ++mutations_
        //delete[] buffer-front_
        free(buffer-front_)
        buffer-cursor_ = buffer-front_ = buffer-end_ = buffer-capacity-end_ =
            nullptr
        capacity_ = size_ = 0
        _Dn( "MutatingBuffer::wipe(): deliberately!\n")
    }

    clear!() -> void    =>      size_ = 0


    /*
        - - - - SYNTAX VARIATIONS - - - -  B-2
    */
    set-specified-buffer-size(size size-t, foo Baloo) void ->  specified-buffer-limit_ = size

    is-at-end!() bool ->
        return (buffer-cursor_ >= buffer-end_)

    is-specification-filled() bool -> {
        _DP("is-specification-filled() -  size = "
            << size_ << " limit = " << specified-buffer-limit_ << "\n")
        return (size_ >= specified-buffer-limit_)
    }

    buffered-count() size-t ->  return (std::min(size_, specified-buffer-limit_))

    consume-specified-buffer() T* ->
        local-fn-1  (count int) void -> rewind-shuffle(count)
        local-fn-2 (count int) void -> { rewind-shuffle(count) }
        a-lambda = [&](foo int) void -> rewind-shuffle(buffered-count())

        if true == false
            rewind-shuffle(buffered-count())
        else
            local-fn1(buffered-count())

        return buffer-front_

    shrink-to-fit!(force bool = false, other-thing int = 1) void ->
        // We simply ignore this and keep the currently allocated amounts..
        return

    wipe!() void -> { // deliberate free / delete
        ++mutations_
        //delete[] buffer-front_
        free(buffer-front_)
        buffer-cursor_ = buffer-front_ = buffer-end_ = buffer-capacity-end_ =
            nullptr
        capacity_ = size_ = 0
        _Dn( "MutatingBuffer::wipe(): deliberately!\n")
    }

    clear!() void   ->  size_ = 0


    /*
        - - - - SYNTAX VARIATIONS - - - -  END
    */






    //! "Rewind the buffer" count T.
    /** Ie: copy what's above count up til buffer size (not capacity) to the
     *  beginning of buffer. Reset size to the amount of copied bytes.
     *  Basically, remove all data that has been handled / consumed and reset
     *  positions to beginning of buffer.
     */
    rewind-shuffle(count ~int) -> void {
            _Dn("rewind-shuffle with " << count << " where size is " << size_)
            assert(count <= size_)
            memmove(buffer-front_, buffer-front_ + count,
                    size_ - count) // We need to use memmove to be really sure.
            size_ = size_ - count
            buffer-end_ = buffer-front_ + size_
            buffer-cursor_ -= count
            _Dn( "size_ after rewind shuffle = " << size_)
    }

    //! The same ~ rewind-shuffle ( int count ) but calculates the count
    //  from the pointer compared to front(). Excluding pointer position!
    rewind-shuffle(buf-ptr ~T*) -> void
            _Dn( "rewind-shuffle with ptr")
            rewind-shuffle((int)(buf-ptr - buffer-front_))

    /*
     *  The ++ should be on the iterator ofcourse!
    & operator++ () -> MutatingBuffer<T> /i/ {
    */

    size!() -> int      =>  return size_
    capacity!() -> int  =>  return capacity_

    push!(val ~T) -> void
            if size_ >= capacity_    // *TODO* `==` should logically suffice - this is an overprotective class-system non-trustive measure..
                // We use +1, but much more will probably be allocated
                reserve(size_ + 1, true)

            acc(val)

    operator! << (val ~T) -> void   =>  push(val)

    append!(val ~T) -> void  // (2014-12-28 Oscar Campbell)
            push(val)

    append!(buf ~void*, len ~size-t) -> void { // (2014-12-28 Oscar Campbell)
            // *TODO* keep track of largest appended block, ~ well ~ largestspan of
            // loose ptr running to estimate future block add sizes for better prediction
            // of pre-allocation

            reserve(size_ + len, true)  if size_ + len > capacity_
            std::memcpy(static-cast<void*>(buffer-cursor_), static-cast<void*>(buf), len)
            buffer-cursor_ += len
    }

    acc!(val ~T) -> void
            *buffer-cursor_ = val
            ++buffer-cursor_
            ++buffer-end_
            ++size_

    reset-write-cursor!() -> void   =>  buffer-cursor_ = buffer-end_
    reset-read-cursor!() -> void    =>  buffer-cursor_ = buffer-front_

#ifdef IS-DEBUG
    on-free-leash-for!(expected-count ~natural) -> T*
            expected-free-leash-movement_ = expected-count
            return buffer-cursor_
#else
    on-free-leash-for!(~natural) -> T*
            return buffer-cursor_
#endif

    catch-up-reads ~ (int count) -> void  /i/ = {
            _Dn( "catch-up-reads, with count int")
            catch-up-reads(buffer-end_ + count)
    }
    catch-up-reads ~ (T* buf-ptr) -> void  /i/ = {
            #ifdef IS-DEBUG
                natural count = int(buf-ptr - buffer-cursor_)
                //_DPn("catch-up-reads, actual count is "
                //     << count << " expected max was " << expected-free-leash-movement_)
                assert(count <= expected-free-leash-movement_)
                assert(buf-ptr <= buffer-capacity-end_)
                //_Dn("ptr: " << (void*)buf-ptr << " and end: " << (void*)buffer-end_ << " ptr-'pos': " << (buf-ptr - buffer-front_))
                assert(buf-ptr <= buffer-end_)
                assert(buf-ptr >= buffer-cursor_)
                assert(buf-ptr > buffer-front_)
                expected-free-leash-movement_ = 0
            #endif

            buffer-cursor_ = buf-ptr
    }

    catch-up-writes ~ (int count) -> void  /i/ =     // Ofcourse blocks can be omitted for funcs too. recommended only for 1-3 liners...
            _Dn( "catch-up-writes, with count int")
            catch-up-writes(buffer-end_ + count)



    catch-up-writes!(T* buf-ptr) -> void {
            count ~int = (int)(buf-ptr - buffer-cursor_)

#           ifdef IS-DEBUG
                _DPn("catch-up-writes, actual count is "
                     << count << " expected max was " << expected-free-leash-movement_)
                assert(count <= expected-free-leash-movement_)
                assert(buf-ptr <= buffer-capacity-end_)
                assert(buf-ptr >= buffer-cursor_)
                assert(buf-ptr > buffer-front_)
                expected-free-leash-movement_ = 0
#           endif

            size_ += count
            buffer-end_ = buffer-cursor_ = buf-ptr

            assert(size_ == int(buffer-end_ - buffer-front_))
            _DPn("catch-up: size_ " << size_ << " buffer-end_ - buffer-front_ "
                                << (buffer-end_ - buffer-front_))
    }

#ifdef IS-DEEPBUG
    verify-pointer!(buf-ptr ~T*) -> bool = {
        // Private function within function
        DONK!(msg ~string) -> void
            #ifndef NDEBUG
                cerr << msg
            #endif
        /*
        -- translates to this, outside of func..:
        `
        private:
         inline void MutatingBuffer::__verify-pointer__DONK_(string msg) { ... }
        `
        */

        |/ buf-ptr > buffer-capacity-end_
            DONK( StrBuf() << "discrepancy: " << (buf-ptr - buffer-front_)
                 << " vs capacity: " << capacity_)


        |/ buf-ptr == nullptr
            DONK( "is fucking null" )

        | buf-ptr < buffer-front_
            DONK( StrBuf() << "discrepancy: " << (buf-ptr - buffer-front_) )

        | buf-ptr > buffer-front + 47
            DONK( "is 47ish" )

        |_
            DONK("seems to be equal - default solution")



        |/ /buf-ptr {1}/
        | == nullptr
            DONK( "is fucking null" )

        | < buffer-front_
            DONK( StrBuf() << "discrepancy: " << (buf-ptr - buffer-front_) )

        | > buffer-front + 47
            DONK( "is 47ish" )

        |_
            DONK("seems to be equal - default solution")


        |/ /buf-ptr {1}/
        | == nullptr            => _Dn( "is fucking null" )
        | < buffer-front_       => _Dn( StrBuf() << "discrepancy: " << (buf-ptr - buffer-front_) )
        | > buffer-front + 47   => _Dn( "is 47ish" )
        |_                      => _Dn("seems to be equal - default solution")


        |/ /buf-ptr {1}/ => /DONK({1})/
        | == nullptr            => "is fucking null"
        | < buffer-front_       => StrBuf() << "discrepancy: " << (buf-ptr - buffer-front_)
        | > buffer-front + 47   => "is 47ish"
        |_                      => "seems to be equal - default solution"


        assert(buf-ptr <= buffer-capacity-end_)
        assert(buf-ptr >= buffer-front_)

        return true
    }
#else
    verify-pointer!(~T*) -> bool  => return true
#endif

    /*
    //! Returns true if re-allocations took place ( = user cached pointers must
    be updated )
    grow ~ ( int size ) -> bool /i/ = {
        T* prev-buf = buffer_

        if  prev-buf != allocate( size, true )
            return true
        } else {
            return false
        }
    }
    */

    /*
    operator ~ () -> T* /i/ = {
        cerr << "auto cast"
        return buffer_
    }
    */
    front ~ () -> T*  /i/ =>
        // cerr << "begin()"
        return buffer-front_

    /i/
    begin ~ () -> T* =
        // cerr << "begin()"
        return buffer-front_

    end ~ /i/ () -> T* =
        // cerr << "end()"
        return buffer-end_

    back ~ () -> T* /i/ =
        // cerr << "end()"
        return buffer-end_

    limit ~ () -> T* =  /i/
        // cerr << "limit()"
        return buffer-capacity-end_

    /i/ spec-limit ~ () -> T* =
        // cerr << "limit()"
        return buffer-front_ + specified-buffer-limit_

   private:
    buffer-front_           ~ T* = nullptr
    buffer-end_             ~ T* = nullptr
    buffer-capacity-end_    ~ T* = nullptr
    buffer-cursor_          ~ T* = nullptr

    capacity_               ~ int = 0
    size_                   ~ int = 0
    specified-buffer-limit_ ~ int = 0

    fixed-margin_   ~ int = 0
    minimum-size_   ~ int = 0
    clean-uses_     ~ f-size-t = 0
    mutations_      ~ f-size-t = 0

    is-just-a-reference_ ~ bool = false

#ifdef IS-DEBUG
    expected-free-leash-movement_ ~int = 0
#endif
}

// Playing with functionalism for aestethics
front-of!<T>(buf ~ MutatingBuffer<T>&) -> T* =>
        return buf.begin()

#endif












// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
// #
// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
// #

#include "UziScalperBot.hh"

// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
// #
#ifdef INTERFACE

#include "QuantBasic_DESIGN_CHOICES.hh"
#include "QuantSuit.hh"
#include "QTA.hh"

#undef DEBUG_BUF_ONEOFF
#undef TEST_ONLY_ONE_BASE_PERIODIZATION


has!<class T>(val ~int, obj ~T&) -> bool  => return int(val) <= obj.count()
not-yet!<T>(val ~int, obj ~T&) -> bool  => return int(val) > obj.count()

typedef QR = QuantReal



class FooTrader<bool FOO = true>    // Just to keep it compiling though all inlined.. *TEMP*
{
  public:
    constructor(feed ~QuantFeedAbstract&, balance ~real, leverage ~int) {
            :> feed(feed)
            :> balance(balance)
            :> initial-deposit(balance)
            :> leverage(leverage)
    }

    destructor() ->
            report()

    deposit(qty ~real) -> void
            balance += qty

    get-equity() -> real
            return balance + (security-qty * ((feed.ticks().bid + feed.ticks().ask) /
                                          2))

    handle-tick!() -> void {
            |/ current-position == 0
                return

            | current-position == 1
                real p = feed.ticks().bid
                if p > last-trail-source-price
                    calculate-trail-price(p)

                if current-stop-loss && p < current-stop-loss
                    cerr << "Closes long because of stop loss\n"
                    close-long()

                elif current-trailing-stop-delta && p < current-trailing-stop
                    cerr << "Closes long because of trailing stop loss\n"
                    close-long()

            | _
                p ~real = feed.ticks().ask
                if p < last-trail-source-price
                    calculate-trail-price(p)

                if current-stop-loss && p > current-stop-loss
                    cerr << "Closes short because of stop loss\n"
                    close-short()

                elif current-trailing-stop-delta && p > current-trailing-stop
                    cerr << "Closes short because of trailing stop loss\n"
                    close-short()
    }
    calculate-trail-price!(price ~real) -> void {
            last-trail-source-price = price
            if current-position == 1
                current-trailing-stop = price * (1 - current-trailing-stop-delta)
            else
                current-trailing-stop = price * (1 + current-trailing-stop-delta)
    }
    buy(qty-percent ~real = 5, stop-loss ~real = 0, trailing-stop ~real = 0) -> bool {
            if current-position == 1
                //cerr << "buy: Already long!" << "\n"
                return false

            elif current-position == -1
                //cerr << "buy: Is short, so we close the short before longing!" << "\n"
                close-short()

            // *TODO* make sure minimum lot size is reached or fail
            current-position = 1
            position-entry-price = feed.ticks().ask
            // Check if stop-loss is given in percent
            if stop-loss != 0 && stop-loss < 0.2
                stop-loss = feed.ticks().bid * (1 - stop-loss)

            current-stop-loss = stop-loss
            current-trailing-stop-delta = trailing-stop
            if trailing-stop
                calculate-trail-price(feed.ticks().bid)

            position-size = qty-percent / 100 * balance
            security-qty = (position-size * leverage) / position-entry-price
            balance -= position-size
            _Dn("Open long at " << position-entry-price << " = size " << security-qty *
                position-entry-price)
            return true
    }
    sell(real qty-percent = 5, real stop-loss = 0, real trailing-stop = 0) -> bool {
            if current-position == -1
                //cerr << "sell: Already short!" << "\n"
                return false

            else if current-position == 1
                //cerr << "sell: Is long, so we close the long before shorting!" << "\n"
                close-long()

            // *TODO* make sure minimum lot size is reached or fail
            current-position = -1
            position-entry-price = feed.ticks().bid
            if stop-loss != 0 && stop-loss < 0.2
                stop-loss = feed.ticks().ask * (1 + stop-loss)
            }
            current-stop-loss = stop-loss
            current-trailing-stop-delta = trailing-stop
            if trailing-stop
                last-trail-source-price = feed.ticks().ask
                current-trailing-stop = feed.ticks().ask * (1 + current-trailing-stop-delta)

            position-size = qty-percent / 100 * balance
            security-qty = (position-size * leverage) / position-entry-price
            balance -= position-size
            _Dn("Open short at " << position-entry-price << " = size " << security-qty *
                position-entry-price)
            return true
    }
    close-long() -> bool
    {
            if current-position != 1
                cerr << "close-long: Not long, so couldn't!" << "\n"
                return false

            current-position = 0
            current-stop-loss = 0
            current-trailing-stop = 0
            current-trailing-stop-delta = 0
            got ~real = security-qty * feed.ticks().bid - security-qty * position-entry-price
            balance += got
            transaction-times.push-back(feed.ticks().time)
            transactions.push-back(got)
            cerr << "closed long opened at " << position-entry-price << " on " <<
                 feed.ticks().bid << " a diff off: " << (feed.ticks().ask -
                         position-entry-price) / position-entry-price * 100 << "\n"
            return true
    }
    close-short() -> bool
    {
            if current-position != -1
                cerr << "close-short: Not short, so couldn't!" << "\n"
                return false

            current-position = 0
            current-stop-loss = 0
            current-trailing-stop = 0
            current-trailing-stop-delta = 0
            real got = -(security-qty * feed.ticks().ask - security-qty *
                      position-entry-price)
            balance += got
            transaction-times.push-back(feed.ticks().time)
            transactions.push-back(got)
            cerr << "closed short opened at " << position-entry-price << " on " <<
                 feed.ticks().ask << " a diff off: " << (position-entry-price -
                         feed.ticks().ask) / position-entry-price * 100 << "\n"
            return true
    }
    report() -> void
    {
            cerr << "RESULTS OF TRADING" << "\n"
            cerr << "\n"
            for i ~ natural = 0; i < transactions.size(); ++i
                cerr << "trade: " << transaction-times[i] << " resulted in " << transactions[i]
                     << "\n"
            }
            cerr << "\n"
            cerr << "Finally: " << balance << " which is " << 100 *
                 (balance - initial-deposit) /
                 initial-deposit << "%" << "\n"
            cerr << "\n"
    }

   private:
    feed ~ QuantFeedAbstract&
    transactions ~ vector<real>
    transaction-times ~ vector<QuantTime>

    initial-deposit ~ real = 0
    balance ~ real = 0
    leverage ~ natural = 0
    current-position ~ int = 0
    position-entry-price ~ real = 0
    position-size ~ real = 0
    security-qty ~ real = 0
    current-trailing-stop-delta ~ real = 0
    current-trailing-stop ~ real = 0
    last-trail-source-price ~ real = 0
    current-stop-loss ~ real = 0
    max-drawdown ~ real = 0
    max-profit ~ real = 0
    max-loss ~ real = 0
}




using namespace QTA



class ZarScalperBot<bool PLOTTING_USED> final : public QuantStudyContext<PLOTTING_USED>
{
    using parent = QuantStudyContext<PLOTTING_USED>
    using self = ZarScalperBot<PLOTTING_USED>

    using parent::plot
    using parent::plot-ohlc
    using parent::close-plot-lap

   public:
    main-symbol     ~string
    symbol2         ~string

    main-feed       ~QuantFeed<self>
    trader          ~FooTrader<true>
    ps              ~QuantPeriodization<self>
    pm              ~QuantPeriodization<self>
    ema-ask         ~Ema
    ema-bid         ~Ema
    ema-ask-l       ~Ema
    ema-bid-l       ~Ema
    ema50pm         ~Ema
    ema200pm        ~Ema
    // PeriodTickMean         meanpm
    mean-ask        ~PeriodTickMean
    mean-bid        ~PeriodTickMean
    highestpm       ~Highest
    lowestpm        ~Lowest
    highestpmlong   ~Highest
    lowestpmlong    ~Lowest
    pl              ~QuantPeriodization<self>
    feed2nd         ~QuantFeed<self>
    // QuantFeed           *main-joint-feed
    handled-ticks-count     ~int = 0
    handled-ticks-count2    ~int = 0
    avg-roc                 ~QR = 0
    max-roc                 ~QR = 0
    one-byter-roc-delta     ~int = 0
    two-byter-roc-delta     ~int = 0
    three-byter-roc-delta   ~int = 0
    four-byter-roc-delta    ~int = 0
    b12-byter-roc-delta     ~int = 0
    floatingEURUSD          ~QR = 0

    #ifdef IS_DEBUG
    do-debug-the-time ~bool = false
    #else
    do-debug-the-time ~constexpr static bool = false
    #endif

    // *TODO* (StrategyInstance)
    constructor(conf ~ HashTree&) -> {
            :> parent(conf)
            :> main-symbol(
                  param("main-symbol", "_CRASH_ME_", "Main instrument"))
            :> symbol2(param("symbol2", "EURUSD", "Complementary instrument"))
            :> main-feed(param("main-broker-id", "_CRASH_ME_", "Main broker"),
                        main-symbol, 10)
            :> trader(main-feed, 40000, 300)
            :> ps(param("fast-period", 0.47, "'Fast' period"), main-feed)
            :> pm(param("pm-period-len", 0.50, "'1 minute' period"))
              // *TODO* the tick-aggregation length should be "abrubtly" changed
              // depending on if "in or out of prime time" - thus dynamic.
            :> ema-ask(param("ask-tick-ema-len", 20000, "Ask Tick EMA length"))
            :> ema-bid(param("bid-tick-ema-len", 20000, "Bid Tick EMA length"))
            :> ema-ask-l(param("ask-tick-ema-len", 5600 /*1600*/,
                              "Ask Tick EMA long length"))
            :> ema-bid-l(param("bid-tick-ema-len", 5600 /*1600*/,
                              "Bid Tick EMA long length"))
            :> ema50pm(param("fast-ema-len", 50 * 10, "Fast EMA length"))
            :> ema200pm(param("mid-ema-len", 200 * 10, "Mid EMA length"))
            :> mean-ask()
            :> mean-bid()
            :> highestpm(param("highest-len", 5, "Highest length"))
            :> lowestpm(param("lowest-len", 5, "Lowest length"))
            :> highestpmlong(param("highest-long-len", 100, "Highest Long length"))
            :> lowestpmlong(param("lowest-long-len", 100, "Lowest Long length"))
            :> pl(param("pl-period-len", 240.0, "'4 hour' period"))
            :> feed2nd { "DUKASCOPY", symbol2, 3 }   // DUKASCOPY_RAW will _not_ be supported from strategies any more...

            cerr << "\nZarScalperBot::ZarScalperBot constructor"
                 << "\n\n"
    }

    destructor() ->
            print-summary()

    init() -> void [final] {
            //main-feed.setRegulatedInterval(ps.getPeriod())
            main-feed.onRegulatedTick_T(this, &self::every-raw-tick)
            feed2nd.onRegulatedTick_T(this, &self::every-raw-tick2)
            ps.onBarClose_T(this, &self::every-ps-close)
            pm.onBarClose_T(this, &self::every-pm-close)
            pl.onBarClose_T(this, &self::every-pl-close)
    }


    every-raw-tick2(QuantFeedAbstract & feed) -> void {
            tick ~ ¤QuantTick& = feed.ticks.last-as-const() // [0]
            if tick.isGhostTick() => return
            ++handled-ticks-count2
            floatingEURUSD = floatingEURUSD * 0.9 + tick.ask * 0.1
            //if not-yet(2, feed.ticks)) // feed.ticks.size < 2  return; }
    }
    // void handleTick_T ( QuantFeed<self> &feed ) {
    every-raw-tick(QuantFeedAbstract & feed) -> void {
            tick ~const QuantTick & = feed.ticks.last-as-const(); // [0]
            if tick.isGhostTick()
                every-ghost-tick(tick)
            else
                every-real-tick(tick)
    }
    every-ghost-tick!(tick ~ const QuantTick&) -> void {
            //_Dn("--> GHOST " << tick.time.time-of-day() << " :: " << tick.ask)
            ps.accumulate-from-feed-tick-ask(tick)
    }
    every-real-tick!(tick ~ const QuantTick&) -> void {
            //_Dn("--> TICK " << tick.time.time-of-day() << " :: " << tick.ask)
            trader.handle-tick();   // tick)
            ps.accumulate-from-feed-tick-ask(tick)
            ++handled-ticks-count
            mean-ask << tick.ask
            mean-bid << tick.bid
            ema-ask << tick.ask
            ema-bid << tick.bid
            ema-ask-l << tick.ask
            ema-bid-l << tick.bid
    }
    every-ps-close() -> void {
            //dlog-candle-time-and-close(ps)
            //do-candle-validations(ps)
            #ifndef TEST_ONLY_ONE_BASE_PERIODIZATION
            pm.accumulate-from-source-candle(ps)
            #endif
    }
    every-pm-close() -> void {
            //dlog-candle-time-and-close(pm)
            //do-candle-validations(pm)
            pl.accumulate-from-source-candle(pm)
            if not-yet(2, pm) => return
            //#define close pm.close
            //#define open pm.open
            //#define high pm.high
            //#define low pm.low
            #if IS_DEEPBUG
            // if  open < 20
            if do-debug-the-time
                cerr << "ZarScalperBot::every-pm-close - "
                // cerr << "#" << pm.barCount() << " - "
                cerr << (pm.time().date().month()) << "-"
                     << (pm.time().date().day()) << " "
                cerr << (pm.time().time-of-day()) << " - " << pm.to-str()
                cerr << " ticks: " << main-feed.real-tick-count << " / "
                     << main-feed.ghost-tick-count
                main-feed.reset-debug-counts()
                cerr << " fltEURUSD: " << floatingEURUSD << " / "
                     << handled-ticks-count2
                handled-ticks-count2 = 0
                cerr << "\n"

            else
                // if ( pm.time > pxt::ptime( dt::date( 2014, 4, 10 ), pxt::hours( 0
                // ) ) )
                // {
                //    do-debug-the-time = true
                //}

            #endif
            ema-ask.produce() // *BUBBLARE* *TODO*
            ema-bid.commit()  // *BUBBLARE* *TODO*
            ema-ask-l.commit() // *BUBBLARE* *TODO*
            ema-bid-l.commit()  // *BUBBLARE* *TODO*
            ema50pm |= pm.close
            ema200pm |= pm.close
            // meanpm |= pm.close
            mean-ask |= main-feed.ticks().ask
            mean-bid |= main-feed.ticks().bid
            highestpm |= pm.high
            lowestpm |= pm.low
            highestpmlong |= pm.high
            lowestpmlong |= pm.low
            // assert( meanpm[0] != 0 )
            // assert( mean-ask[0] != 0 )
            // assert( mean-bid[0] != 0 )
            dta-50-200 ~QR = ema50pm - ema200pm
            dta-c-50 ~QR = pm.close - ema50pm
            // QR angl30 = angle(ema30[0])
            // cerr << "50-200: " << dta-50-200 << " dta-c-50: " << dta-c-50 <<
            // "\n"
            hlc3 ~QR = (pm.close + pm.high + pm.low) * (1. / 3)
            granular-close ~auto = main-feed.ticks().ask
            #ifdef DEBUG_BUF_ONEOFF
            #ifdef IS_DEEPBUG

            // if `(has 2 pm) && `(has 4 main-feed.ticks)   -- backticks on parantheses causes lisp-style parsing (!)
            if has(2, pm) && has(4, main-feed.ticks)
                // if  pm.count() >= 2 && main-feed.ticks.count() >= 4
                cerr << "\n"
                     << "pm.close " << pm.close << "  ps.close " << ps.close
                     << "  ps.close[1] " << ps.close[1] << "  feed.ask[0..3] = ["
                     << main-feed.ticks[0].ask << ", " << main-feed.ticks[1].ask
                     << ", " << main-feed.ticks[2].ask << ", "
                     << main-feed.ticks[3].ask << "]"
                     << ""
            }
            #endif
            #endif
            /*
            assert( pm.close == ps.close )
            assert( granular-close == pm.close )
            */
            /*

            */
            midp ~QR = 1.003 * (main-feed.ticks().bid + main-feed.ticks().ask) / 2
            //bool is-sell = ema-ask < ema-ask-l && ema-bid < ema-bid-l
            //bool is-buy = ema-ask > ema-ask-l && ema-bid > ema-bid-l
            is-sell ~bool = ema-ask-l - ema-ask-l[1] <
                           -0.0001; // < ema-ask-l && ema-bid < ema-bid-l
            is-buy ~bool = ema-ask-l  - ema-ask-l[1] >
                          0.0001; // ema-ask > ema-ask-l && ema-bid > ema-bid-l
            |/ is-sell
                if trader.sell(5, 0, 0.005)
                    plot(midp * (1 - 0.001), "trade")
                else
                    plot(midp, "trade")

            | is-buy
                if trader.buy(5, 0, 0.005)
                    plot(midp * (1 + 0.001), "trade")

                else
                    plot(midp, "trade")

            | _
                plot(midp, "trade")
            /*

            */
            if PLOTTING_USED {  // && is-primed
                plot-ohlc(pm.open, pm.high, pm.low, pm.close, "main-instrument", "aaffaa",
                          "ffaaaa", "005500", "550000", true)
                plot(pm.high, "high", "337733", 1, LINE)
                plot(pm.low, "low", "773333", 1, LINE)
                //plot(pm.close, "close", "ffaaaa", 4, LINE)
                //plot(pm.close[0], "close[0]", "bbffbb", 3, LINE)
                //plot(pm.close(), "close())", "ccccff", 2, LINE)
                /*
                plot(hlc3, "hlc3-c-D",
                     (pm.close > pm.close[1] ? "003300" : "000033"), 1, CIRCLE,
                     DASHED, true)
                */
                // plot( hlc3, "hlc3", "0000ff", 1, CIRCLE, DASHED, true )
                // plot( ema50pm, "ema50", "0000ff", 2, DIAMOND, DOTTED )
                plot(mean-ask, "mean-ask", "000000", 3, PLUS)
                plot(mean-bid, "mean-bid", "555555", 1, PLUS)
                plot(ema-ask-l, "mean-ask-l", "ff0000", 3, CIRCLE)
                plot(ema-bid-l, "mean-bid-l", "ff5555", 1, CIRCLE)
                plot(ema-ask, "var-ema-ask", "0000ff", 3, SQUARE)
                plot(ema-bid, "var-ema-ask", "5555ff", 1, SQUARE)
                // plot( ( ema-ask + ema-bid ) / 2 , "ema-ask-bid-midpoint",
                // "000055", 2,
                // DASH, DOTTED )
                plot(ema200pm, "ema200", "ff0000", 3, LINE, DASHED)
                // plot( highestpm, "highest-high", "00aa00", 1, DASH, DASHED )
                // plot( lowestpm, "lowest-low", "aa0000", 1, DASH, DASHED )
                // plot( ( highestpm + lowestpm ) * ( 1.0 / 2.0 ), "mid", "dddddd",
                // 0,
                // CROSS, NONE pl
                // this->close-plot-lap( pm.time )
                // pltext<PLOTTING_USED>::close-plot-lap( pm.time )
                // plot( ( 1.0 / feed2nd.ticks().ask ) * 15.24, "EURUSD p", "ffaaaa"
                // )
                plot(granular-close * 1.000, "granular close", "000000", 3)
                plot(main-feed.ticks().ask * 1.000, "ticks.ask", "444444", 2)
                close-plot-lap(pm.time)
            }
    }

    every-pl-close() -> void
            //cerr << "ZarScalperBot::handle<" << pl.getPeriod()
            //     << "> - : " << pl.time() << " " << pl.to-str() << "\n"
            /*
            `(assert pl.close == pm.close )
            */


    dlog-candle-time-and-close!(periodization QuantPeriodizationAbstract&) -> void
            _Dn("--> candle(" << periodization.getPeriod() << ") " <<
                periodization.time().time-of-day() << " :: " << periodization.close)

    do-candle-validations!(periodization QuantPeriodizationAbstract&) -> void
            #ifdef IS_DEBUG

            if ``(periodization has 2)       // --> has(periodization, 2)   - conversely: `(has periodization 2)  --> has(periodization, 2)  -- the tick-count suggests where the verb (function-id) is..
                if periodization.time[1] == periodization.time[0]
                    _Dn("\n\n\nDuplicated timestamp in periodization<" << periodization.getPeriod()
                        << "!!! : " << periodization.time << "\n\n\n")


            #endif

    print-summary() -> void
            cerr << "\n\n"
            cerr << "- - - - - -- - - - - - - - - - - - - "
                 << "\n"
            cerr << "ZarScalperBot >> >>> DESTRUCTOQR <<< <<"
                 << "\n"
            cerr << "floatingEURUSD = " << floatingEURUSD << "\n"
            cerr << "Avg ROC: " << avg-roc * 100000 << "\n"
            cerr << "Max ROC: " << max-roc * 100000 << "\n"
            cerr << "\n"
            cerr << "Amount of handled ticks: " << handled-ticks-count << "\n"
            cerr << "Amount of raw bytes / ticks: " << (handled-ticks-count * 40) /
                 1024 / 1024 << "MB\n"
            cerr << "Amount of handled 2nd feed ticks: " << handled-ticks-count2
                 << "\n"
            cerr << "Amount of raw bytes / 2nd feed ticks: "
                 << (handled-ticks-count2 * 40) / 1024 / 1024 << "MB\n"
            cerr << "both in raw bytes: "
                 << ((handled-ticks-count + handled-ticks-count2) * 40) / 1024 /
                 1024 << "MB\n"
            cerr << "\n"
            cerr << "No. of one-byter-roc-delta: " << one-byter-roc-delta << "\n"
            cerr << "No. of two-byter-roc-delta: " << two-byter-roc-delta << "\n"
            cerr << "No. of three-byter-roc-delta: " << three-byter-roc-delta
                 << "\n"
            cerr << "No. of four-byter-roc-delta: " << four-byter-roc-delta << "\n"
            cerr << "Total byte-size compressed: "
                 << (one-byter-roc-delta + two-byter-roc-delta * 2 +
                     three-byter-roc-delta * 3 + four-byter-roc-delta * 4) /
                 1024 / 1024 << "MB"
                 << "\n"
            cerr << "Total byte-size RAW: "
                 << (one-byter-roc-delta * 8 + two-byter-roc-delta * 8 +
                     three-byter-roc-delta * 8 + four-byter-roc-delta * 8) /
                 1024 / 1024 << "MB"
                 << "\n"
            // cerr << "No. of 1.5-byter-roc-delta: " << b12-byter-roc-delta <<
            // "\n"
            cerr << "- - - - - -- - - - - - - - - - - - - "
                 << "\n"
}

#endif

createStrategy(
    exec-space ~ QuantExecutionContext&,
    conf ~ HashTree

) -> QuantStudyContextAbstract*
{
        bot ~QuantStudyContextAbstract*
        if exec-space.isBuffersOutputEnabled()
            _Dn("Create Plotting ZarScalperBot<true>")
            bot = new ZarScalperBot<true>(conf)
        }
        else {
            _Dn("Create Optimized ZarScalperBot<false>")
            bot = new ZarScalperBot<false>(conf)
        }
        return bot
}

destroyStrategy(QuantStudyContextAbstract * strategy) -> void {
        delete strategy
}

#define QUANT_STUDY
#include "../ext/T23MFW/src/QuantExecution-standalone-main.cc"
